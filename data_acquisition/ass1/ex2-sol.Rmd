---
title: "Exercise 2"
author: "Andreas Merckel, 00746397"
date: "17.03.2021"
output:
  pdf_document: default
  html_document: default
subtitle: "First Assigment: Introduction to Importing Data in R"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### read.csv

In this exercise we learned the usage of the R function read.csv(), which is used to import comma-separated values into R. str() gives us an overview over the imported data.
```{r}
# Import swimming_pools.csv: pools
pools <- read.csv("data/swimming_pools.csv")
# Print the structure of pools
str(pools)
```

### stringsAsFactors

In this exercise we learned how we can tell read.csv() to convert any strings in the underlying imported file to factors or not with the corresponding option. Importing strings as factors makes sense if the strings you import are supposed to represent categorical variables in R.
```{r}
# Import swimming_pools.csv correctly: pools
pools <- read.csv("data/swimming_pools.csv", stringsAsFactors = FALSE)

# Check the structure of pools
str(pools)
```

### Any changes?
A multiple choice question regarding the stringsAsFactors option, the correct answer is ```Two variables: Name and Address.```


### read.delim
read.delim can be used when you need to customize the delimiter.

```{r}
# Import hotdogs.txt: hotdogs
hotdogs <- read.delim(header=FALSE, "data/hotdogs.txt")

# Summarize hotdogs
summary(hotdogs)
```

### read.table
read.table can be used when there is the need to have even more options regarding the underlying file format separators.

```{r}
# Path to the hotdogs.txt file: path
path <- file.path("data", "hotdogs.txt")

# Import the hotdogs.txt file: hotdogs
hotdogs <- read.table(path, head=FALSE, 
                      sep = '\t', 
                      col.names = c("type", "calories", "sodium"))

# Call head() on hotdogs
head(hotdogs)
```

### Arguments
This exercise is putting the above together: We are using the possible arguments in read.delim() to read in real-world data. We learn that we can give custom names to eventual columns in our dataset, by providing an appropriate vector.

```{r}
# Finish the read.delim() call
hotdogs <- read.delim("data/hotdogs.txt", header = FALSE, col.names = c("type", "calories", "sodium"))

# Select the hot dog with the least calories: lily
lily <- hotdogs[which.min(hotdogs$calories), ]

# Select the observation with the most sodium: tom
tom <- hotdogs[which.max(hotdogs$sodium), ]

# Print lily and tom
lily
tom
```

### Column classes 
Additionally to naming columns, we can also decide the types, with another vector called colClasses.

```{r}
# Previous call to import hotdogs.txt
hotdogs <- read.delim("data/hotdogs.txt", header = FALSE, col.names = c("type", "calories", "sodium"))

# Display structure of hotdogs
str(hotdogs)

# Edit the colClasses argument to import the data correctly: hotdogs2
hotdogs2 <- read.delim("data/hotdogs.txt", header = FALSE, 
                       col.names = c("type", "calories", "sodium"),
                       colClasses = c("factor", "NULL", "numeric"))

# Display structure of hotdogs2
str(hotdogs2)
```

### read_csv
This function comes from the readr package and is a wrapper function for read.csv(), so i.e. it is used for common use-cases instead of having to fiddle around with all the options in read.csv().

```{r}
# Load the readr package
library(readr)

# Import potatoes.csv with read_csv(): potatoes
potatoes <- read_csv("data/potatoes.csv")
```

### read_tsv
Like read_csv(), read_tsv() is a wrapper function for tab-separated values.

```{r}
# readr is already loaded

# Column names
properties <- c("area", "temp", "size", "storage", "method",
                "texture", "flavor", "moistness")

# Import potatoes.txt: potatoes
potatoes <- read_tsv("data/potatoes.txt", col_names=properties)

# Call head() on potatoes
head(potatoes)
```

### read_delim
As the above, read_delim comes from the readr package and is corresponding to read.table() in its functionality.

```{r}
# readr is already loaded

# Column names
properties <- c("area", "temp", "size", "storage", "method",
                "texture", "flavor", "moistness")

# Import potatoes.txt using read_delim(): potatoes
potatoes <- read_delim("data/potatoes.txt", delim="\t", col_names=properties)

# Print out potatoes
potatoes
```

### skip and n_max
These options for read_tsv help us to specify which part of our data we want to import.

```{r}
# readr is already loaded

# Column names
properties <- c("area", "temp", "size", "storage", "method",
                "texture", "flavor", "moistness")

# Import 5 observations from potatoes.txt: potatoes_fragment
potatoes_fragment <- read_tsv("data/potatoes.txt", skip = 6, n_max = 5, col_names = properties)
```

### col_types
col_types from the readr package is used to specify the types of the columns.

```{r}
# readr is already loaded

# Column names
properties <- c("area", "temp", "size", "storage", "method",
                "texture", "flavor", "moistness")

# Import all data, but force all columns to be character: potatoes_char
potatoes_char <- read_tsv("data/potatoes.txt", col_types = "cccccccc", col_names = properties)

# Print out structure of potatoes_char
str(potatoes_char)
```

### col_types with collectors
The argument col_types can also be called with a list to set the types.

```{r}
# readr is already loaded

# Import without col_types
hotdogs <- read_tsv("data/hotdogs.txt", col_names = c("type", "calories", "sodium"))

# Display the summary of hotdogs
summary(hotdogs)

# The collectors you will need to import the data
fac <- col_factor(levels = c("Beef", "Meat", "Poultry"))
int <- col_integer()

# Edit the col_types argument to import the data correctly: hotdogs_factor
hotdogs_factor <- read_tsv("data/hotdogs.txt",
                           col_names = c("type", "calories", "sodium"),
                           col_types = list(fac, int, int))

# Display the summary of hotdogs_factor
summary(hotdogs_factor)
```

### fread
fread is a function from the data.table package and corresponds to read.table() from above. It is better at predicting the correct types and values and faster than read.table()

```{r}
# load the data.table package
library(data.table);

# Import potatoes.csv with fread(): potatoes
potatoes <- fread("data/potatoes.csv");

# Print out potatoes
potatoes
```

### fread: more advanced use
fread() can also take additional arguments for deciding how our data should be imported. Additionally, we plot() the data in this exercise.

```{r}
# fread is already loaded

# Import columns 6 and 8 of potatoes.csv: potatoes
potatoes <- fread("data/potatoes.csv", select = c(6, 8));

# Plot texture (x) and moistness (y) of potatoes
plot(potatoes$texture, potatoes$moistness, xlab="texture", ylab="moistness")
```

### Dedicated classes
A multiple choice question regarding classes and fread(), the correct answer is:
The class of the result of ```fread()``` is both data.table and data.frame. read_csv() creates an object with three classes: tbl_df, tbl and data.frame.

### List the sheets of an Excel file
We learn the usage of excel_sheets(), provided from the readxl package, which makes it possible to read in excel sheets in a convenient way.

```{r}
# Load the readxl package
library(readxl)

# Print the names of all worksheets
excel_sheets("data/urbanpop.xlsx")
```


### Import an Excel sheet
We can name the sheets and combine them into a list.

```{r}
# The readxl package is already loaded

# Read the sheets, one by one
pop_1 <- read_excel("data/urbanpop.xlsx", sheet = 1);
pop_2 <- read_excel("data/urbanpop.xlsx", sheet = 2);
pop_3 <- read_excel("data/urbanpop.xlsx", sheet = 3);

# Put pop_1, pop_2 and pop_3 in a list: pop_list
pop_list = list(pop_1, pop_2, pop_3);

# Display the structure of pop_list
str(pop_list)
```

### Reading a workbook
lapply() allows us to read in and merge our excel sheets in a convenient way.

```{r}
# The readxl package is already loaded

# Read all Excel sheets with lapply(): pop_list
pop_list <- lapply(excel_sheets("data/urbanpop.xlsx"),
                   read_excel, path = "data/urbanpop.xlsx");

# Display the structure of pop_list
str(pop_list)
```


### The col_names argument
This argument allows us to specify the header and the column names for the dataframe. If set to FALSE, R will choose the names, if set to TRUE, the first row in the excel sheet will be used for naming.

```{r}
# The readxl package is already loaded

# Import the first Excel sheet of urbanpop_nonames.xlsx (R gives names): pop_a
pop_a <- read_excel("data/urbanpop_nonames.xlsx", col_names = FALSE)

# Import the first Excel sheet of urbanpop_nonames.xlsx (specify col_names): pop_b
cols <- c("country", paste0("year_", 1960:1966))
pop_b <- read_excel("data/urbanpop_nonames.xlsx", col_names = cols)

# Print the summary of pop_a
summary(pop_a)

# Print the summary of pop_b
summary(pop_b)
```

### The skip argument
This argument allows us to specify if we want to exclude a certain amount of entries in our underlying data.

```{r}
# The readxl package is already loaded

# Import the second sheet of urbanpop.xlsx, skipping the first 21 rows: urbanpop_sel
urbanpop_sel = read_excel("data/urbanpop.xlsx",
                          col_names = FALSE,
                          skip = 21, sheet = 2)

# Print out the first observation from urbanpop_sel
head(urbanpop_sel, n = 1)
```

### Import a local file
The gdata package provides its own function to read in excel sheets. It takes arguments to specify the name of the specific sheet.

```{r}
# Load the gdata package
library(gdata)

# Import the second sheet of urbanpop.xls: urban_pop
urban_pop <- read.xls("data/urbanpop.xls", sheet = "1967-1974")

# Print the first 11 observations using head()
head(urban_pop, n = 11)
```

### read.xls() wraps around read.table()
Here we learn that we can specify arguments for read.xls() in the same way as read.table(), e.g. sheet, skip, header, stringsAsFactors, col.names.

```{r}
# The gdata package is alreaded loaded

# Column names for urban_pop
columns <- c("country", paste0("year_", 1967:1974))

# Finish the read.xls call
urban_pop <- read.xls("data/urbanpop.xls", sheet = 2,
                      skip = 50, header = FALSE, stringsAsFactors = FALSE,
                      col.names = columns)

# Print first 10 observation of urban_pop
head(urban_pop, n = 10)
```

### Work that Excel data!
cbind() can be used to combine multiple sheets, na.omit() allows us to clean the data, by removing NA values.

```{r}
# Add code to import data from all three sheets in urbanpop.xls
path <- "data/urbanpop.xls"
urban_sheet1 <- read.xls(path, sheet = 1, stringsAsFactors = FALSE)
urban_sheet2 <- read.xls(path, sheet = 2, stringsAsFactors = FALSE)
urban_sheet3 <- read.xls(path, sheet = 3, stringsAsFactors = FALSE)


# Extend the cbind() call to include urban_sheet3: urban
urban <- cbind(urban_sheet1, urban_sheet2[-1], urban_sheet3[-1])

# Remove all rows with NAs from urban: urban_clean
urban_clean <- na.omit(urban)
```

### Connect to a workbook
The package XLConnect allows us to use functions that can again be used to work with Excel worksheets. For the initial connection, it provides us with the loadWorkbook() function.

```{r}
# urbanpop.xlsx is available in your working directory

# Load the XLConnect package
library(XLConnect)

# Build connection to urbanpop.xlsx: my_book
my_book <- loadWorkbook("data/urbanpop.xlsx")

# Print out the class of my_book
class(my_book)
```

### List and read excel sheets
getSheets() and readWorksheets() from the XLConnect package can be used to list and load sheets, respectively.

```{r}
# XLConnect is already available

# Build connection to urbanpop.xlsx
my_book <- loadWorkbook("data/urbanpop.xlsx")

# List the sheets in my_book
getSheets(my_book)

# Import the second sheet in my_book
sheet2 = readWorksheet(my_book, sheet = 2)
```

### Customize readWorksheet
We can use startCol and endCol to decide which columns we want to import and cbind() to combine our selection together.

```{r}
# XLConnect is already available

# Build connection to urbanpop.xlsx
my_book <- loadWorkbook("data/urbanpop.xlsx")

# Import columns 3, 4, and 5 from second sheet in my_book: urbanpop_sel
urbanpop_sel <- readWorksheet(my_book, sheet = 2, startCol = 3, endCol = 5)

# Import first column from second sheet in my_book: countries
countries <- readWorksheet(my_book, sheet = 2, startCol = 1, endCol = 1)

# cbind() urbanpop_sel and countries together: selection
selection <- cbind(countries, urbanpop_sel)
```

### Add worksheet
Unlike the other approaches used so far, the connection to an actual workbook provided by XLConnect makes it possible to manipulate excel sheets from inside R.

```{r}
# XLConnect is already available

# Build connection to urbanpop.xlsx
my_book <- loadWorkbook("data/urbanpop.xlsx")

# Add a worksheet to my_book, named "data_summary"
createSheet(my_book, "data_summary")

# Use getSheets() on my_book
getSheets(my_book)
```

### Populate worksheet
As described, we get an actual connection to a workbook from XLConnect. We can use this to populate our workbook from R with writeWorksheet() and save it to the worksheet with saveWorksheet().

```{r}
# XLConnect is already available

# Build connection to urbanpop.xlsx
my_book <- loadWorkbook("data/urbanpop.xlsx")

# Add a worksheet to my_book, named "data_summary"
createSheet(my_book, "data_summary")

# Create data frame: summ
sheets <- getSheets(my_book)[1:3]
dims <- sapply(sheets, function(x) dim(readWorksheet(my_book, sheet = x)), USE.NAMES = FALSE)
summ <- data.frame(sheets = sheets,
                   nrows = dims[1, ],
                   ncols = dims[2, ])

# Add data in summ to "data_summary" sheet
writeWorksheet(my_book, summ, sheet = "data_summary")
# Save workbook as summary.xlsx
saveWorkbook(my_book, "data/summary.xlsx")
```

### Renaming sheets
In the same manner as above, renameSheet() can be used to rename a worksheet.

```{r}
# my_book is available

# Rename "data_summary" sheet to "summary"
renameSheet(my_book, sheet = 4, "summary")

# Print out sheets of my_book
getSheets(my_book)

# Save workbook to "renamed.xlsx"
saveWorkbook(my_book, "data/renamed.xlsx")
```


### Removing sheets
In the same manner as above, renameSheet() can be used to remove a worksheet.

```{r}
# Load the XLConnect package
library(XLConnect)

# Build connection to renamed.xlsx: my_book
my_book <- loadWorkbook("data/renamed.xlsx")

# Remove the fourth sheet
removeSheet(my_book, "summary")

# Save workbook to "clean.xlsx"
saveWorkbook(my_book, "data/clean.xlsx")
```
